"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractAt = exports.fetchAbiAt = void 0;
const axios_1 = __importDefault(require("axios"));
const ethers_1 = require("ethers");
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const chainIds_1 = __importDefault(require("./constants/chainIds"));
const rpcs_json_1 = __importDefault(require("./constants/rpcs.json"));
const etherscan_1 = require("./etherscan");
const types_1 = require("./types");
const fetchAbiAt = (address, { provider, rpcUrl, network, apiKey }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let chainId = 1;
    if (!provider && !rpcUrl) {
        network !== null && network !== void 0 ? network : (network = "mainnet");
        chainId = ethers_1.ethers.utils.isHexString(network)
            ? parseInt(network, 16)
            : /^\d+$/.test(network)
                ? Number(network)
                : chainIds_1.default[network.toLowerCase()];
        // @ts-ignore
        rpcUrl !== null && rpcUrl !== void 0 ? rpcUrl : (rpcUrl = (_a = rpcs_json_1.default[chainId.toString()]) === null || _a === void 0 ? void 0 : _a.rpcs[0]);
    }
    if (provider || rpcUrl) {
        provider !== null && provider !== void 0 ? provider : (provider = new ethers_1.ethers.providers.JsonRpcBatchProvider(rpcUrl));
        try {
            address = yield (0, upgrades_core_1.getImplementationAddress)(provider, address);
        }
        catch (error) {
            if (!(error instanceof upgrades_core_1.EIP1967ImplementationNotFound))
                throw error;
        }
        chainId = provider.network.chainId;
    }
    const { data } = yield axios_1.default.get((0, etherscan_1.getEtherscanUrl)(chainId, "contract", {
        action: "getsourcecode",
        address,
        apiKey,
    }));
    if ((0, types_1.isEtherscanError)(data))
        throw new Error(data.result);
    try {
        return {
            name: data.result[0].ContractName,
            abi: JSON.parse(data.result[0].ABI),
        };
    }
    catch (_b) {
        throw new Error(data.result[0].ABI);
    }
});
exports.fetchAbiAt = fetchAbiAt;
const getContractAt = (address, signerOrProvider) => __awaiter(void 0, void 0, void 0, function* () {
    return new ethers_1.ethers.Contract(address, (yield (0, exports.fetchAbiAt)(address, {
        provider: ethers_1.ethers.providers.Provider.isProvider(signerOrProvider)
            ? signerOrProvider
            : undefined,
    })).abi, signerOrProvider);
});
exports.getContractAt = getContractAt;
